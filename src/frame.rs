//! # Frame Module
//!
//! This module provides the implementation of the SA430 protocol frame structure and related functionalities.
//! It defines constants, enums, and functions to handle the creation, parsing, and validation of frames
//! used in communication with SA430 devices.
//!
//! ## Usage Example
//! ```rust
//! use sa430::frame::{Command, Frame};
//!
//! fn main() {
//!   let frame = Frame::new(Command::GetIdn);
//!   let bytes = frame.to_bytes();
//!   let parsed_frame = Frame::from_bytes(&bytes).unwrap();
//!
//!   assert_eq!(frame, parsed_frame);
//! }
//! ```
use std::{
    error::Error,
    fmt::{self, Display},
};

use super::crc::crc16;

/// Magic value for the SA430 protocol.
pub const FRAME_MAGIC_VALUE: u8 = 0x2A;

/// Frame magic value index.
pub const FRAME_MAGIC_INDEX: usize = 0;

/// Frame data length index.
pub const FRAME_DATA_LENGTH_INDEX: usize = 1;

/// Frame command index.
pub const FRAME_COMMAND_INDEX: usize = 2;

/// Frame data index.
pub const FRAME_DATA_INDEX: usize = 3;

/// Frame header size (magic, length, command).
pub const FRAME_HEADER_SIZE: usize = 3;

/// Frame CRC size.
pub const FRAME_CRC_SIZE: usize = 2;

/// SA430 command codes.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord)]
pub enum Command {
    /// Unknown
    #[default]
    Unknown = 0x00,

    /// Get IDN
    GetIdn = 0x01,

    /// Get Hardware Serial Number
    GetSerialNumber = 0x02,

    /// Hardware Reset (PUC)
    HardwareReset = 0x03,

    /// Identify hardware by blinking LED
    BlinkLed = 0x04,

    /// Get core version
    GetCoreVersion = 0x05,

    /// Error
    GetLastError = 0x06,

    /// Unknown
    Sync = 0x07,

    /// Get Spectrum version
    GetSpectrumVersion = 0x14,

    /// Set Start Frequency `fstart`
    SetFStart = 0x15,

    /// Set Stop Frequency `fstop`
    SetFStop = 0x16,

    /// Set Step Frequency `fstep`
    SetFStep = 0x17,

    /// Unknown
    SetFrq = 0x18,

    /// Set Rx Filter Bandwidth
    SetRbw = 0x19,

    /// Set DC value for the balun (unknown)
    SetDac = 0x1A,

    /// Set gain of the Rx path
    SetGain = 0x1B,

    /// Set Intermediate Frequency
    SetIf = 0x1C,

    /// Setup system for spectrum measurement
    InitParameter = 0x1E,

    /// Measure spectrum with defined parameters
    GetSpecNoInit = 0x1F,

    /// Get prod version
    GetProdVer = 0x3C,

    /// Unknown
    SetProdFwInit = 0x3D,

    /// Unknown
    GetTemp = 0x3E,

    /// Set hardware id
    SetHardwareId = 0x3F,

    /// Get Hardware id
    GetHardwareId = 0x40,

    /// Boot count
    GetBootCnt = 0x41,

    /// 0=Off, 1=26MHz, 2=RF Freq.  (next bytes)
    SetFout = 0x42,

    /// Set frequency, incl. temp/cal versions
    SetFxtal = 0x43,

    /// Get frequency, incl. temp/cal versions
    GetFxtal = 0x44,

    /// f, gain, repetition count
    SweepEdc = 0x45,

    /// Unknown
    GetChipTlv = 0x49,

    /// Send address and size, get flash content
    FlashRead = 0x0A,

    /// Unknown
    FlashWrite = 0x0B,

    /// Unknown
    FlashErase = 0x0C,

    /// Unknown
    FlashGetCrc = 0x0D,

    /// Frame Error
    FrameError = 0xFF,
}

impl fmt::Display for Command {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let description = match self {
            Command::Unknown => "Unknown",
            Command::GetIdn => "Get IDN",
            Command::GetSerialNumber => "Get Hardware Serial Number",
            Command::HardwareReset => "Hardware Reset (PUC)",
            Command::BlinkLed => "Identify hardware by blinking LED",
            Command::GetCoreVersion => "Get core version",
            Command::GetLastError => "Error",
            Command::Sync => "Unknown",
            Command::GetSpectrumVersion => "Get Spec version",
            Command::SetFStart => "Set Start Frequency `fstart`",
            Command::SetFStop => "Set Stop Frequency `fstop`",
            Command::SetFStep => "Set Step Frequency `fstep`",
            Command::SetFrq => "Unknown",
            Command::SetRbw => "Set Rx Filter Bandwidth",
            Command::SetDac => "Set DC value for the balun (unknown)",
            Command::SetGain => "Set gain of the Rx path",
            Command::SetIf => "Set Intermediate Frequency",
            Command::InitParameter => "Setup system for spectrum measurement",
            Command::GetSpecNoInit => "Measure spectrum with defined parameters",
            Command::GetProdVer => "Get prod version",
            Command::SetProdFwInit => "Unknown",
            Command::GetTemp => "Unknown",
            Command::SetHardwareId => "Set hardware id",
            Command::GetHardwareId => "Get Hardware id",
            Command::GetBootCnt => "Boot count",
            Command::SetFout => "0=Off, 1=26MHz, 2=RF Freq.  (next bytes)",
            Command::SetFxtal => "Set frequency, incl. temp/cal versions",
            Command::GetFxtal => "Get frequency, incl. temp/cal versions",
            Command::SweepEdc => "f, gain, repetition count",
            Command::GetChipTlv => "Unknown",
            Command::FlashRead => "Send address and size, get flash content",
            Command::FlashWrite => "Unknown",
            Command::FlashErase => "Unknown",
            Command::FlashGetCrc => "Unknown",
            Command::FrameError => "Frame Error",
        };
        write!(f, "{}", description)
    }
}

impl From<u8> for Command {
    fn from(value: u8) -> Self {
        match value {
            0x00 => Command::Unknown,
            0x01 => Command::GetIdn,
            0x02 => Command::GetSerialNumber,
            0x03 => Command::HardwareReset,
            0x04 => Command::BlinkLed,
            0x05 => Command::GetCoreVersion,
            0x06 => Command::GetLastError,
            0x07 => Command::Sync,
            0x14 => Command::GetSpectrumVersion,
            0x15 => Command::SetFStart,
            0x16 => Command::SetFStop,
            0x17 => Command::SetFStep,
            0x18 => Command::SetFrq,
            0x19 => Command::SetRbw,
            0x1A => Command::SetDac,
            0x1B => Command::SetGain,
            0x1C => Command::SetIf,
            0x1E => Command::InitParameter,
            0x1F => Command::GetSpecNoInit,
            0x3C => Command::GetProdVer,
            0x3D => Command::SetProdFwInit,
            0x3E => Command::GetTemp,
            0x3F => Command::SetHardwareId,
            0x40 => Command::GetHardwareId,
            0x41 => Command::GetBootCnt,
            0x42 => Command::SetFout,
            0x43 => Command::SetFxtal,
            0x44 => Command::GetFxtal,
            0x45 => Command::SweepEdc,
            0x49 => Command::GetChipTlv,
            0x0A => Command::FlashRead,
            0x0B => Command::FlashWrite,
            0x0C => Command::FlashErase,
            0x0D => Command::FlashGetCrc,
            0xFF => Command::FrameError,
            _ => Command::Unknown,
        }
    }
}

/// SA430 Error codes.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord)]
pub enum ErrorCode {
    NoError = 0x0000,
    CmdBufferOverflow = 0x0320,
    WrongCmdLength = 0x0321,
    CmdAborted = 0x0322,
    LostCmd = 0x0323,
    UnknownCmd = 0x0324,
    TooMuchDataRequestedByUserFunction = 0x0325,
    RestoreProgramCounter = 0x0326,
    BufferPosOutOfRange = 0x0327,
    EeqBufferOverflow = 0x0328,
    WrongCrcLowByte = 0x0329,
    WrongCrcHighByte = 0x032A,
    RestoreFromPacketError = 0x032C,
    NoFrameStart = 0x032D,
    WrongPacketLength = 0x032E,
    PacketIncomplete = 0x032F,
    PacketError = 0x0330,
    StupidPacketHandler = 0x0331,
    BufferOverflow = 0x0352,
    BufferUnderrun = 0x0353,
    FlashNotErased = 0x044C,
    FlashMismatch = 0x044D,
    RssiValidFlagNotSet = 0x04B0,
    PllNotSettled = 0x04B1,
    #[default]
    Unknown = 0xFFFF,
}

impl fmt::Display for ErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let description = match self {
            ErrorCode::NoError => "OK",
            ErrorCode::CmdBufferOverflow => "Command buffer overflow",
            ErrorCode::WrongCmdLength => "Wrong command length",
            ErrorCode::CmdAborted => "Command aborted",
            ErrorCode::LostCmd => "Lost command",
            ErrorCode::UnknownCmd => "Unknown command",
            ErrorCode::TooMuchDataRequestedByUserFunction => "Too much data requested by user function",
            ErrorCode::RestoreProgramCounter => "Restore program counter",
            ErrorCode::BufferPosOutOfRange => "Buffer position out of range",
            ErrorCode::EeqBufferOverflow => "EEQ buffer overflow",
            ErrorCode::WrongCrcLowByte => "Wrong CRC low byte",
            ErrorCode::WrongCrcHighByte => "Wrong CRC high byte",
            ErrorCode::RestoreFromPacketError => "Restore from packet error",
            ErrorCode::NoFrameStart => "No frame start",
            ErrorCode::WrongPacketLength => "Wrong packet length",
            ErrorCode::PacketIncomplete => "Packet incomplete",
            ErrorCode::PacketError => "Packet error",
            ErrorCode::StupidPacketHandler => "Stupid packet handler",
            ErrorCode::BufferOverflow => "Buffer overflow",
            ErrorCode::BufferUnderrun => "Buffer underrun",
            ErrorCode::FlashNotErased => "Flash not erased",
            ErrorCode::FlashMismatch => "Flash mismatch",
            ErrorCode::RssiValidFlagNotSet => "RSSI valid flag not set",
            ErrorCode::PllNotSettled => "PLL not settled",
            ErrorCode::Unknown => "Unknown error",
        };
        write!(f, "{}", description)
    }
}

impl fmt::UpperHex for ErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:04X}", *self as u16)
    }
}

impl From<Vec<u8>> for ErrorCode {
    fn from(value: Vec<u8>) -> Self {
        let code = u16::from_be_bytes([value[0], value[1]]);
        match code {
            0x0000 => ErrorCode::NoError,
            0x0320 => ErrorCode::CmdBufferOverflow,
            0x0321 => ErrorCode::WrongCmdLength,
            0x0322 => ErrorCode::CmdAborted,
            0x0323 => ErrorCode::LostCmd,
            0x0324 => ErrorCode::UnknownCmd,
            0x0325 => ErrorCode::TooMuchDataRequestedByUserFunction,
            0x0326 => ErrorCode::RestoreProgramCounter,
            0x0327 => ErrorCode::BufferPosOutOfRange,
            0x0328 => ErrorCode::EeqBufferOverflow,
            0x0329 => ErrorCode::WrongCrcLowByte,
            0x032A => ErrorCode::WrongCrcHighByte,
            0x032C => ErrorCode::RestoreFromPacketError,
            0x032D => ErrorCode::NoFrameStart,
            0x032E => ErrorCode::WrongPacketLength,
            0x032F => ErrorCode::PacketIncomplete,
            0x0330 => ErrorCode::PacketError,
            0x0331 => ErrorCode::StupidPacketHandler,
            0x0352 => ErrorCode::BufferOverflow,
            0x0353 => ErrorCode::BufferUnderrun,
            0x044C => ErrorCode::FlashNotErased,
            0x044D => ErrorCode::FlashMismatch,
            0x04B0 => ErrorCode::RssiValidFlagNotSet,
            0x04B1 => ErrorCode::PllNotSettled,
            _ => ErrorCode::Unknown,
        }
    }
}

/// Error types for the SA430 protocol.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum FrameError {
    /// Invalid magic value (current value).
    InvalidMagicValue(u8),

    /// Invalid frame length (expected, current).
    InvalidFrameLength(u8, u8),

    /// Invalid CRC (expected, current).
    InvalidCrc(u16, u16),
}

impl Error for FrameError {}

impl Display for FrameError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FrameError::InvalidMagicValue(current) => {
                write!(
                    f,
                    "Invalid magic value, expected 0x{:02X}, current: 0x{:02X}",
                    FRAME_MAGIC_VALUE, current
                )
            }
            FrameError::InvalidFrameLength(expected, current) => {
                write!(
                    f,
                    "Invalid frame length, expected 0x{:02X}, current: 0x{:02X}",
                    expected, current
                )
            }
            FrameError::InvalidCrc(expected, current) => {
                write!(
                    f,
                    "Invalid CRC, expected: 0x{:04X}, current: 0x{:04X}",
                    expected, current
                )
            }
        }
    }
}

/// SA430 Frame.
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord)]
pub struct Frame {
    cmd: Command,
    data: Vec<u8>,
}

impl Frame {
    /// Creates a new frame with default values.
    pub fn new(cmd: Command) -> Self {
        Frame { cmd, data: vec![] }
    }

    /// Creates a new frame with the given command and data.
    pub fn with_data(cmd: Command, data: &[u8]) -> Self {
        Frame {
            cmd,
            data: data.to_vec(),
        }
    }

    /// Returns the command of the frame.
    pub fn cmd(&self) -> Command {
        self.cmd
    }

    /// Returns the data of the frame.
    pub fn data(&self) -> &[u8] {
        &self.data
    }

    /// Returns true if the frame is an error.
    pub fn is_error(&self) -> bool {
        self.cmd == Command::GetLastError
    }

    /// Creates a frame from a byte array.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, FrameError> {
        Frame::validate(bytes)?;
        Frame::parse(bytes)
    }

    /// Creates a byte array from the frame.
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = vec![FRAME_MAGIC_VALUE, self.data.len() as u8, self.cmd as u8];
        bytes.append(&mut self.data.clone());
        let crc = crc16(&bytes);
        bytes.append(&mut crc.to_be_bytes().to_vec());
        bytes
    }

    /// Returns the error code if the frame is an error.
    pub fn to_error_code(&self) -> Option<ErrorCode> {
        match self.cmd() {
            Command::GetLastError => Some(self.data.clone().into()),
            _ => None,
        }
    }

    /// Validates the frame bytes.
    fn validate(bytes: &[u8]) -> Result<(), FrameError> {
        if bytes[FRAME_MAGIC_INDEX] != FRAME_MAGIC_VALUE {
            return Err(FrameError::InvalidMagicValue(bytes[FRAME_MAGIC_INDEX]));
        }

        if bytes.len() - 5 != bytes[FRAME_DATA_LENGTH_INDEX] as usize {
            return Err(FrameError::InvalidFrameLength(
                bytes[FRAME_DATA_LENGTH_INDEX],
                (bytes.len() - 5) as u8,
            ));
        }

        let frame_crc = u16::from_be_bytes([bytes[bytes.len() - 2], bytes[bytes.len() - 1]]);
        let computed_crc = crc16(&bytes[..bytes.len() - 2]);
        if frame_crc != computed_crc {
            return Err(FrameError::InvalidCrc(frame_crc, computed_crc));
        }

        Ok(())
    }

    /// Parses the frame bytes.
    fn parse(bytes: &[u8]) -> Result<Self, FrameError> {
        let cmd = Command::from(bytes[FRAME_COMMAND_INDEX]);
        let data = bytes[FRAME_DATA_INDEX..bytes.len() - FRAME_CRC_SIZE].to_vec();

        Ok(Frame { cmd, data })
    }
}

pub mod fixture {
    //! # Fixture Module
    //!
    //! This module provides predefined data fixtures for testing purposes. These fixtures include
    //! various byte arrays that represent different types of data frames used in the SA430 protocol.
    //!
    //! ## Constants
    //!
    //! - `PROG_HEADER_DATA`: A byte array representing a program header data frame.
    //! - `CALIBRATION_DATA_1..7`: A byte array representing the first set of calibration data.
    //!
    //! These constants can be used in tests to validate the functionality of frame parsing, validation,
    //! and other related operations.
    //!
    //! ## Usage Example
    //!
    //! ```rust
    //! use sa430::frame::fixture::{PROG_HEADER_DATA, CALIBRATION_DATA_1, CALIBRATION_DATA_2};
    //!
    //! fn main() {
    //!     // Example usage of the fixtures in a test
    //!     assert_eq!(PROG_HEADER_DATA.len(), 10);
    //!     assert_eq!(CALIBRATION_DATA_1.len(), 256);
    //!     assert_eq!(CALIBRATION_DATA_2.len(), 32);
    //! }
    //! ```

    use super::*;

    pub const PROG_HEADER_DATA: &[u8] = &[0, 212, 212, 6, 62, 0, 0, 2, 2, 18];

    pub const CALIBRATION_DATA_1: &[u8] = &[
        0x01, 0x10, 0x4d, 0x6f, 0x2e, 0x20, 0x53, 0x65, 0x70, 0x20, 0x31, 0x39, 0x20, 0x32, 0x30, 0x31, 0x31, 0x00,
        0x01, 0x20, 0x02, 0x11, 0x49, 0x0c, 0x80, 0x14, 0xdc, 0x93, 0x80, 0x00, 0x00, 0x00, 0x0a, 0x16, 0xf2, 0xa2,
        0x40, 0x1b, 0xb7, 0x56, 0x40, 0x00, 0x00, 0x00, 0x0a, 0x2d, 0xe5, 0x44, 0x80, 0x37, 0x6e, 0xac, 0x80, 0x00,
        0x00, 0x00, 0x1e, 0xdd, 0x80, 0xd8, 0x90, 0xd3, 0x91, 0xce, 0x4a, 0xc9, 0x0c, 0xc4, 0xb3, 0xbf, 0x2c, 0xba,
        0x3d, 0x00, 0x00, 0x09, 0x08, 0x30, 0x38, 0x46, 0x46, 0x34, 0x31, 0x45, 0x35, 0x30, 0x46, 0x38, 0x42, 0x33,
        0x41, 0x33, 0x34, 0x01, 0x8c, 0xb8, 0xe4, 0x00, 0x10, 0x00, 0x28, 0x04, 0x3f, 0x08, 0x99, 0x0a, 0x28, 0x04,
        0x3f, 0x08, 0xa2, 0x07, 0x41, 0x67, 0xfe, 0x9e, 0xfa, 0x34, 0x47, 0x23, 0xbf, 0xd2, 0xc1, 0x41, 0xe2, 0x39,
        0x79, 0x59, 0x3e, 0x29, 0x09, 0x28, 0x2e, 0x93, 0xf1, 0xb2, 0xbc, 0x72, 0x80, 0x84, 0xd2, 0x5a, 0x96, 0x98,
        0x3a, 0xb0, 0x5a, 0xe6, 0x32, 0x89, 0xf4, 0x2f, 0xb8, 0xe1, 0x4b, 0xde, 0xcd, 0xbd, 0xe5, 0xc0, 0x37, 0x04,
        0x44, 0x4c, 0x82, 0xc0, 0xef, 0x3c, 0xb5, 0x14, 0x4c, 0xfa, 0x20, 0x6a, 0x15, 0xee, 0x05, 0xc1, 0x69, 0x2b,
        0x2e, 0xe6, 0xf6, 0x86, 0xe5, 0x3f, 0xd2, 0x29, 0xd4, 0x7f, 0xef, 0xf8, 0x5d, 0xbe, 0x26, 0x74, 0xa5, 0x84,
        0x2b, 0xe5, 0xb6, 0x3c, 0x6e, 0xd3, 0xa7, 0xdb, 0xc9, 0x29, 0xde, 0xba, 0xa9, 0x5f, 0xf6, 0x35, 0xa5, 0xc7,
        0xbb, 0x38, 0xd9, 0x0c, 0x7c, 0x8e, 0xc7, 0x8b, 0x88, 0xb6, 0xfb, 0x75, 0x12, 0xe8, 0x6b, 0x33, 0x3c, 0x35,
        0x09, 0xc8, 0x39, 0x3f, 0x8a, 0x8c, 0xbd, 0x07, 0x41, 0x61, 0xdc, 0x9a, 0x37, 0xdd, 0xc7, 0x01, 0xbf, 0xca,
        0x8b, 0x44, 0xe9,
    ];

    pub const CALIBRATION_DATA_2: &[u8] = &[
        0x3f, 0x6a, 0xd0, 0x3e, 0x20, 0xe5, 0x17, 0x41, 0x13, 0xc2, 0x6a, 0xbc, 0x67, 0xe1, 0x7b, 0xe7, 0xd6, 0x04,
        0x31, 0x3a, 0xa4, 0x3d, 0x6f, 0x5a, 0xa6, 0x89, 0x33, 0xb8, 0xd4, 0x92, 0x54, 0x69, 0x9a, 0x3a, 0xe8, 0x36,
        0xf7, 0x37, 0x71, 0x2b, 0x4c, 0x7b, 0xbc, 0xb5, 0x06, 0x71, 0x97, 0x84, 0x1f, 0xe6, 0x74, 0x06, 0xc1, 0x95,
        0x0c, 0x3c, 0xc7, 0xf3, 0xc8, 0x32, 0x3f, 0xff, 0x18, 0x0f, 0xce, 0x62, 0x29, 0x8d, 0xbe, 0x53, 0xab, 0xdf,
        0x1a, 0x2e, 0x52, 0x8d, 0x3c, 0x9b, 0xa2, 0x53, 0xa2, 0x88, 0xff, 0x8b, 0xba, 0xd7, 0x46, 0x24, 0xa6, 0x7b,
        0xb3, 0xa6, 0x39, 0x07, 0x81, 0x05, 0xaf, 0xcc, 0xf8, 0x2d, 0xb7, 0x2a, 0x5a, 0x6a, 0x82, 0xf0, 0x5b, 0x7c,
        0x35, 0x39, 0x4e, 0x99, 0x69, 0xa6, 0xe4, 0x91, 0x07, 0x41, 0x8a, 0x31, 0x37, 0x27, 0x12, 0x8f, 0xde, 0xbf,
        0xf3, 0x3a, 0x5f, 0x51, 0x6b, 0x24, 0x23, 0x3e, 0x48, 0x2e, 0x32, 0x66, 0x54, 0x0d, 0xd2, 0xbc, 0x90, 0xe1,
        0xa9, 0xa8, 0xff, 0xea, 0x8a, 0x3a, 0xcc, 0x44, 0x0e, 0xec, 0x19, 0x94, 0x6b, 0xb8, 0xfc, 0x60, 0x73, 0x5a,
        0xda, 0xd5, 0xb6, 0x37, 0x1f, 0xa1, 0xbe, 0xb5, 0xcf, 0xd8, 0x1d, 0xb5, 0x2e, 0x33, 0xe8, 0x0f, 0x42, 0xf4,
        0x3d, 0x07, 0xc1, 0x84, 0x0f, 0xe1, 0x67, 0x45, 0x03, 0x0d, 0x3f, 0xed, 0x52, 0xbc, 0x74, 0x6e, 0x49, 0xd1,
        0xbe, 0x42, 0x5b, 0x2f, 0xd8, 0xfc, 0x73, 0x25, 0x3c, 0x89, 0x84, 0xc2, 0x89, 0xf9, 0xed, 0x6a, 0xba, 0xc5,
        0x45, 0x83, 0x80, 0xaa, 0x2a, 0x2a, 0x38, 0xf5, 0x43, 0x89, 0x75, 0x26, 0x6d, 0xa0, 0xb7, 0x17, 0x9a, 0x4b,
        0x68, 0x3e, 0xd4, 0x7e, 0x35, 0x26, 0x71, 0x1d, 0x63, 0x6b, 0xde, 0x9b, 0x07, 0xc1, 0x77, 0x1b, 0x5f, 0x05,
        0x4b, 0x59, 0x5f,
    ];

    pub const CALIBRATION_DATA_3: &[u8] = &[
        0x3f, 0xe1, 0x66, 0x97, 0x36, 0x84, 0x60, 0x0b, 0xbe, 0x36, 0x6f, 0xb0, 0x3a, 0xf7, 0x4f, 0xd7, 0x3c, 0x80,
        0x0d, 0x64, 0x37, 0x07, 0x86, 0x06, 0xba, 0xbb, 0x87, 0xc8, 0x60, 0x2a, 0x6c, 0x41, 0x38, 0xec, 0x4b, 0xa5,
        0x95, 0x7b, 0xbe, 0x87, 0xb7, 0x10, 0x23, 0x23, 0xb7, 0x4e, 0x87, 0xc5, 0x35, 0x1f, 0x84, 0x3a, 0xc3, 0xa8,
        0x68, 0xbc, 0x07, 0x41, 0x74, 0xc6, 0x50, 0x28, 0x2a, 0xcc, 0xd1, 0xbf, 0xde, 0x6a, 0x0c, 0x5d, 0x60, 0x3c,
        0x96, 0x3e, 0x33, 0x10, 0xe8, 0x60, 0x0c, 0x92, 0xa8, 0xbc, 0x7a, 0x89, 0x71, 0xfc, 0x8d, 0x83, 0xa2, 0x3a,
        0xb6, 0x24, 0x4b, 0xfe, 0x91, 0x50, 0x9d, 0xb8, 0xe6, 0x26, 0x81, 0x3d, 0x35, 0x7b, 0x48, 0x37, 0x08, 0x99,
        0xa3, 0x36, 0xb0, 0xd6, 0x5f, 0xb5, 0x17, 0x65, 0xe8, 0xff, 0xd1, 0xca, 0xaa, 0x01, 0x40, 0x53, 0x9f, 0xff,
        0xfc, 0x3e, 0x7a, 0xa0, 0x3d, 0x0f, 0x3c, 0x0b, 0xb5, 0x94, 0x24, 0x30, 0xbb, 0x5b, 0xb0, 0x4a, 0xb2, 0xc0,
        0x59, 0x40, 0x39, 0x9b, 0x1e, 0x06, 0xdb, 0x12, 0x52, 0x30, 0xb7, 0xcf, 0xa9, 0xfb, 0xc6, 0xac, 0xea, 0xd0,
        0x35, 0xf6, 0x05, 0x27, 0x8c, 0x13, 0x3a, 0x60, 0xb4, 0x10, 0xde, 0x7e, 0x3e, 0xd8, 0xfa, 0x10, 0x32, 0x15,
        0xed, 0xec, 0x42, 0x18, 0x14, 0x40, 0x01, 0x40, 0x53, 0x5f, 0xff, 0xf4, 0xf5, 0x93, 0x89, 0x3d, 0x28, 0x36,
        0xb3, 0xe4, 0x5a, 0xac, 0x70, 0xbb, 0x76, 0xbd, 0x98, 0x8b, 0x0f, 0x15, 0x54, 0x39, 0xb7, 0xb6, 0x1f, 0x7b,
        0xb3, 0xe7, 0x1c, 0xb7, 0xed, 0xa5, 0x27, 0x06, 0xca, 0x31, 0x8c, 0x36, 0x16, 0x38, 0x8e, 0x3e, 0x6f, 0xea,
        0x80, 0xb4, 0x32, 0x7e, 0x0c, 0x68, 0x01, 0x18, 0xf8, 0x32, 0x3a, 0x5c, 0x9a, 0xd6, 0xc0, 0xa3, 0x2c, 0x01,
        0x41, 0x68, 0x36,
    ];

    pub const CALIBRATION_DATA_4: &[u8] = &[
        0x99, 0xdb, 0x13, 0x77, 0x05, 0xbf, 0xcb, 0x70, 0x29, 0xbb, 0xb0, 0xf8, 0x16, 0x3e, 0x1a, 0x9f, 0xf4, 0xeb,
        0x68, 0xa4, 0xa0, 0xbc, 0x5c, 0xad, 0x6c, 0xdc, 0xc3, 0x57, 0xe9, 0x3a, 0x92, 0x83, 0x91, 0xa8, 0x7f, 0x46,
        0x27, 0xb8, 0xbc, 0xa7, 0xe6, 0xe1, 0x0b, 0x89, 0x02, 0x36, 0xd8, 0x9d, 0x58, 0x99, 0xed, 0x81, 0x01, 0xb4,
        0xe2, 0x1a, 0x72, 0xd5, 0xe2, 0xbf, 0xb1, 0x07, 0x41, 0x91, 0xf4, 0xe1, 0x92, 0x0e, 0x3d, 0x0a, 0xbf, 0xf3,
        0xde, 0x94, 0x3d, 0xd4, 0x08, 0xb4, 0x3e, 0x42, 0xd4, 0xf5, 0xc4, 0x39, 0x82, 0x50, 0xbc, 0x83, 0xd1, 0x54,
        0xe0, 0x97, 0xf1, 0x5d, 0x3a, 0xb9, 0x02, 0x3c, 0x93, 0x81, 0x00, 0x48, 0xb8, 0xe2, 0xec, 0x33, 0x1d, 0xdd,
        0xc5, 0xed, 0x36, 0xff, 0xcb, 0x9b, 0xca, 0x98, 0xf2, 0x2a, 0xb5, 0x06, 0xe1, 0x89, 0x53, 0x02, 0x8d, 0xf8,
        0x07, 0x41, 0x9a, 0x84, 0xc1, 0x88, 0x67, 0xeb, 0x96, 0xbf, 0xfd, 0x90, 0xde, 0x26, 0x63, 0x4a, 0xcd, 0x3e,
        0x4c, 0x3b, 0x8b, 0xd1, 0x15, 0x00, 0xf6, 0xbc, 0x8d, 0xee, 0x87, 0x28, 0x7c, 0xd4, 0x66, 0x3a, 0xc3, 0x06,
        0x6b, 0x7d, 0x31, 0xbb, 0xb8, 0xb8, 0xec, 0xff, 0xe6, 0x67, 0xe8, 0xe8, 0x40, 0x37, 0x08, 0x89, 0xcb, 0xe4,
        0x5b, 0x6c, 0x00, 0xb5, 0x11, 0xc8, 0x75, 0x2d, 0x1c, 0x19, 0x00, 0x01, 0x40, 0x53, 0x7f, 0xff, 0xf7, 0xe0,
        0x54, 0x29, 0x3d, 0x21, 0x7f, 0x51, 0xcb, 0x5e, 0x15, 0x7c, 0xbb, 0x70, 0x20, 0x47, 0xeb, 0x44, 0xdd, 0x78,
        0x39, 0xb0, 0x7c, 0xb5, 0xc3, 0x1d, 0x25, 0xdc, 0xb7, 0xe4, 0x31, 0xbc, 0xc0, 0x0b, 0xad, 0xf8, 0x36, 0x0d,
        0xa1, 0xca, 0x00, 0x9e, 0xdc, 0xb8, 0xb4, 0x28, 0x1d, 0x31, 0x60, 0x31, 0x39, 0xb8, 0x32, 0x30, 0xca, 0x57,
        0xc0, 0x41, 0x39,
    ];

    pub const CALIBRATION_DATA_5: &[u8] = &[
        0xf4, 0x07, 0x41, 0x91, 0x82, 0xb9, 0x64, 0x84, 0xe9, 0x92, 0xbf, 0xf3, 0x94, 0x5b, 0x8e, 0x30, 0x6b, 0x14,
        0x3e, 0x42, 0xc0, 0x3b, 0x3c, 0x18, 0x11, 0xf5, 0xbc, 0x83, 0xef, 0xe9, 0x91, 0xc2, 0xbc, 0x1f, 0x3a, 0xb9,
        0x6b, 0x13, 0xec, 0xc4, 0x53, 0xe3, 0xb8, 0xe3, 0x6d, 0xad, 0xca, 0xa2, 0x6c, 0x74, 0x37, 0x00, 0x7c, 0xad,
        0x04, 0x72, 0x34, 0x21, 0xb5, 0x07, 0xf7, 0x1a, 0xd5, 0x6e, 0x91, 0x08, 0x07, 0x41, 0x85, 0xa0, 0xfe, 0x4d,
        0x4a, 0x52, 0x25, 0xbf, 0xe8, 0x05, 0x18, 0xfd, 0x3e, 0x33, 0x3a, 0x3e, 0x36, 0xd8, 0x5a, 0x4f, 0x19, 0x3a,
        0x43, 0xbc, 0x78, 0x1f, 0x0e, 0x66, 0x7d, 0x92, 0xa9, 0x3a, 0xae, 0x89, 0x40, 0xfa, 0x24, 0x9e, 0x11, 0xb8,
        0xd7, 0x2c, 0x8a, 0x1d, 0xf5, 0xb5, 0x94, 0x36, 0xf3, 0x86, 0x16, 0x65, 0x72, 0x71, 0x37, 0xb4, 0xfc, 0x2c,
        0x31, 0x08, 0xcb, 0x26, 0xe5, 0x02, 0x41, 0xb0, 0xec, 0x97, 0x7b, 0x13, 0x1b, 0xef, 0xc0, 0x02, 0xef, 0xb8,
        0xae, 0x8b, 0xf2, 0xda, 0x3e, 0x42, 0x25, 0xea, 0xb9, 0xd1, 0xe0, 0xc8, 0xbc, 0x73, 0x4f, 0xae, 0x8d, 0xae,
        0xcc, 0xbd, 0x3a, 0x98, 0xa4, 0x0f, 0x95, 0x8a, 0x21, 0x91, 0xb8, 0xb2, 0xd9, 0xdc, 0x4b, 0xbc, 0x36, 0xa0,
        0x36, 0xc0, 0x03, 0x1e, 0xd3, 0xe7, 0xea, 0xf4, 0xb4, 0xb7, 0x4c, 0x65, 0xd6, 0x21, 0xb0, 0x09, 0x02, 0x41,
        0xad, 0xf1, 0xe6, 0xc4, 0x14, 0xb6, 0x6d, 0xc0, 0x00, 0xcc, 0xd9, 0x35, 0x24, 0x26, 0xef, 0x3e, 0x40, 0x25,
        0x35, 0x10, 0x3c, 0x9e, 0x27, 0xbc, 0x71, 0x39, 0xf2, 0xe1, 0xd4, 0x45, 0xa3, 0x3a, 0x96, 0x09, 0xc0, 0xb4,
        0xb0, 0x88, 0xbc, 0xb8, 0xb0, 0xe7, 0x16, 0xd5, 0x36, 0x44, 0x92, 0x36, 0xbc, 0xc9, 0x10, 0x93, 0xf3, 0x43,
        0x3b, 0xb4, 0xb4,
    ];

    pub const CALIBRATION_DATA_6: &[u8] = &[
        0xfd, 0xfc, 0xc2, 0xf2, 0x95, 0x40, 0x01, 0x41, 0xa8, 0x05, 0xeb, 0x04, 0xea, 0x68, 0x72, 0xbf, 0xfa, 0xeb,
        0x62, 0x9b, 0xf3, 0xbd, 0xbf, 0x3e, 0x39, 0xd6, 0x0f, 0xdb, 0x3e, 0x87, 0x1e, 0xbc, 0x6b, 0x87, 0xd5, 0x26,
        0xf3, 0xbc, 0xf4, 0x3a, 0x91, 0x96, 0x8e, 0x84, 0x2d, 0xa1, 0x99, 0xb8, 0xaa, 0xf2, 0x34, 0x19, 0xcf, 0x3d,
        0x70, 0x36, 0xb6, 0xea, 0xc5, 0x97, 0x40, 0x5e, 0x77, 0xb4, 0xb0, 0xb1, 0x61, 0x17, 0x5c, 0xa0, 0xa1, 0x01,
        0x41, 0x94, 0x68, 0xa3, 0xe7, 0x64, 0x46, 0x02, 0xbf, 0xe7, 0x5e, 0xc2, 0x21, 0x48, 0x48, 0x19, 0x3e, 0x26,
        0xe8, 0xa7, 0x3b, 0x75, 0x3c, 0x66, 0xbc, 0x58, 0xeb, 0x68, 0xbb, 0x12, 0x92, 0x64, 0x3a, 0x80, 0x3e, 0x37,
        0x83, 0x28, 0x75, 0x1c, 0xb8, 0x99, 0x60, 0x82, 0x36, 0xaf, 0x94, 0xc3, 0x36, 0xa5, 0xff, 0x5b, 0xab, 0x0a,
        0xe0, 0x51, 0xb4, 0xa0, 0x52, 0x98, 0x10, 0x39, 0x5e, 0x81, 0x02, 0x41, 0xa9, 0xa1, 0x39, 0x5c, 0x93, 0x5f,
        0xe1, 0xbf, 0xfc, 0xde, 0x2b, 0xb5, 0xb3, 0xce, 0xdf, 0x3e, 0x3b, 0xd8, 0x92, 0xd8, 0x22, 0x2f, 0xbe, 0xbc,
        0x6d, 0xd1, 0x9d, 0x9f, 0x3c, 0xc6, 0xd1, 0x3a, 0x93, 0x24, 0x5c, 0x64, 0xb6, 0x88, 0xb8, 0xb8, 0xad, 0x77,
        0x27, 0x19, 0xfa, 0x03, 0xc6, 0x36, 0xb9, 0x2c, 0xed, 0xa2, 0x4b, 0x24, 0x8b, 0xb4, 0xb2, 0x6b, 0xb4, 0x12,
        0x75, 0xb6, 0xcd, 0x01, 0x41, 0xac, 0x6b, 0x71, 0xf1, 0x00, 0xe3, 0x8b, 0xbf, 0xff, 0xeb, 0x23, 0xbf, 0xb6,
        0xc3, 0x88, 0x3e, 0x3e, 0xb3, 0xa6, 0x23, 0x26, 0xea, 0x6b, 0xbc, 0x70, 0x64, 0x8c, 0x86, 0xfd, 0x2b, 0x64,
        0x3a, 0x94, 0xfd, 0x2c, 0x82, 0x41, 0x31, 0x08, 0xb8, 0xb0, 0x1c, 0x5b, 0x12, 0xc5, 0x11, 0xef, 0x36, 0xbb,
        0x75, 0x20, 0xb1,
    ];

    pub const CALIBRATION_DATA_7: &[u8] = &[
        0x3e, 0x35, 0x38, 0xb4, 0xb4, 0x09, 0xcb, 0x24, 0x9c, 0x6d, 0xe5, 0x02, 0x41, 0xb6, 0x3d, 0xee, 0x2f, 0x42,
        0xd7, 0xdb, 0xc0, 0x08, 0xe8, 0xd4, 0x77, 0x30, 0x5f, 0xd0, 0x3e, 0x47, 0xe4, 0xbc, 0x54, 0x43, 0x45, 0x55,
        0xbc, 0x79, 0x72, 0x28, 0x58, 0xcd, 0x75, 0x5d, 0x3a, 0xa0, 0x3f, 0x37, 0x7d, 0x6e, 0x3b, 0xff, 0xb8, 0xb8,
        0xe0, 0x7f, 0x28, 0xfb, 0xf5, 0x70, 0x36, 0xc5, 0x25, 0x1f, 0xef, 0xa0, 0xea, 0xdf, 0xb4, 0xbe, 0xc9, 0x4d,
        0xa9, 0x4c, 0xf4, 0x06, 0x02, 0x41, 0xb6, 0x97, 0x67, 0x5d, 0x9c, 0xc8, 0xd7, 0xc0, 0x09, 0x44, 0x46, 0x5f,
        0x4d, 0xed, 0xd9, 0x3e, 0x48, 0x34, 0x51, 0xc9, 0xc6, 0xd9, 0x25, 0xbc, 0x79, 0xbe, 0x87, 0x93, 0xf7, 0x20,
        0xde, 0x3a, 0xa0, 0x6a, 0xcb, 0xfb, 0xf7, 0x71, 0xf9, 0xb8, 0xb9, 0x1b, 0x89, 0xdf, 0xc3, 0x0f, 0x01, 0x36,
        0xc5, 0x50, 0xfa, 0x40, 0xae, 0xe3, 0x28, 0xb4, 0xbf, 0x00, 0x36, 0x7e, 0x4c, 0xbb, 0x92, 0xFF, 0xFF, 0xFF,
    ];

    /// Fake acknoledge response for a `command`
    pub fn an_ack_response(command: Command) -> Frame {
        Frame::new(command)
    }

    /// Fake get idn response
    pub fn a_get_idn_response() -> Frame {
        Frame::with_data(
            Command::GetIdn,
            b"Texas Instruments,MSP-SA430-SUB1GHZ: RF Dev Support Tool,HW2.0",
        )
    }

    /// Fake get serial number response
    pub fn a_get_serial_number_response() -> Frame {
        Frame::with_data(Command::GetSerialNumber, &0x0908u32.to_be_bytes())
    }

    /// Fake get core version response
    pub fn a_get_core_version_response() -> Frame {
        Frame::with_data(Command::GetCoreVersion, &0x020Au16.to_be_bytes())
    }

    /// Fake get spectrum version response
    pub fn a_get_spectrum_version_response() -> Frame {
        Frame::with_data(Command::GetSpectrumVersion, &0x0205u16.to_be_bytes())
    }

    /// Fake flash read response
    ///
    /// Use this function to create a fake response for a flash read command with the constants defined in this module.
    pub fn a_read_flash_response(data: &[u8]) -> Frame {
        Frame::with_data(Command::FlashRead, data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn given_a_command_when_new_then_return_frame() {
        let frame = Frame::new(Command::GetIdn);
        assert_eq!(frame.cmd(), Command::GetIdn);
        assert_eq!(frame.data(), vec![]);
    }

    #[test]
    fn given_a_command_and_data_when_with_data_then_return_frame() {
        let frame = Frame::with_data(Command::GetIdn, &vec![0x01, 0x02, 0x03]);
        assert_eq!(frame.cmd(), Command::GetIdn);
        assert_eq!(frame.data(), vec![0x01, 0x02, 0x03].as_slice());
    }

    #[test]
    fn given_a_frame_when_cmd_is_get_last_error_then_is_error_return_true() {
        let frame = Frame::new(Command::GetLastError);
        assert!(frame.is_error());
    }

    #[test]
    fn given_a_frame_when_cmd_is_not_get_last_error_then_is_error_return_false() {
        let frame = Frame::new(Command::GetIdn);
        assert!(!frame.is_error());
    }

    #[test]
    fn given_bytes_when_from_bytes_then_return_frame() {
        let bytes = vec![0x2A, 0x04, 0x0A, 0xD4, 0x00, 0x00, 0x0A, 0xCD, 0xAD];
        let frame = Frame::from_bytes(&bytes).unwrap();
        assert_eq!(frame.cmd(), Command::FlashRead);
        assert_eq!(frame.data(), vec![0xD4, 0x00, 0x00, 0x0A].as_slice());
    }

    #[test]
    fn given_a_wrong_magic_number_when_from_bytes_then_return_error() {
        let bytes = vec![0x2B, 0x04, 0x0A, 0xD4, 0x00, 0x00, 0x0A, 0xCD, 0xAD];
        let result = Frame::from_bytes(&bytes);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), FrameError::InvalidMagicValue(0x2B));
    }

    #[test]
    fn given_a_wrong_frame_length_when_from_bytes_then_return_error() {
        let bytes = vec![0x2A, 0x03, 0x0A, 0xD4, 0x00, 0x00, 0x0A, 0xCD, 0xAD];
        let result = Frame::from_bytes(&bytes);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), FrameError::InvalidFrameLength(0x03, 0x04));
    }

    #[test]
    fn given_a_wrong_crc_when_from_bytes_then_return_error() {
        let bytes = vec![0x2A, 0x04, 0x0A, 0xD4, 0x00, 0x00, 0x0A, 0xCD, 0xAE];
        let result = Frame::from_bytes(&bytes);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), FrameError::InvalidCrc(0xCDAE, 0xCDAD));
    }

    #[test]
    fn given_a_frame_when_to_bytes_then_return_bytes() {
        let frame = Frame::with_data(Command::FlashRead, &vec![0xD4, 0x00, 0x00, 0x0A]);
        let bytes = frame.to_bytes();
        assert_eq!(bytes, vec![0x2A, 0x04, 0x0A, 0xD4, 0x00, 0x00, 0x0A, 0xCD, 0xAD]);
    }

    #[test]
    fn given_an_error_when_to_error_code_then_return_error_code() {
        let frame = Frame::with_data(Command::GetLastError, &vec![0x03, 0x20]);
        let error_code = frame.to_error_code().unwrap();
        assert_eq!(error_code, ErrorCode::CmdBufferOverflow);
    }
}
